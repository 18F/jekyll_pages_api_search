#! /usr/bin/env ruby
# Author: Mike Bland <michael.bland@gsa.gov>
# Date:   2015-06-21

require_relative '../lib/jekyll_pages_api_search'
require 'fileutils'
require 'jekyll_pages_api'
require 'zlib'

JPAS = ::JekyllPagesApiSearch
ASSETS_DIR = JPAS::JavascriptCopier::ASSETS_DIR

USAGE=<<END_USAGE
#{$0}: generate a lunr.js index from Jekyll Pages API output

Usage:
  #{$0} basedir config.yml pages.json
    uses an existing pages.json to build the index
  #{$0} basedir config.yml pages.json baseURL title_prefix body_element_tag
    produces pages.json and pages.json.gz in addition to the index
  #{$0} --assets baseURL interface.scss interface.html load.js
    produce assets for search interface provided by each {scss,html,js} path
  #{$0} -h

The resulting index will be saved in basedir/search-index.json. A gzipped
version will be produced as well. The JavaScript bundle containing the search
integration code will be stored in basedir/#{ASSETS_DIR}.

Arguments:
  -h
    Print this help message
  --assets
    Produces individual search interface assets:
      interface.scss: style for search-interface.html
      interface.html: HTML fragment containing search interface element
      load.js: <script> element that loads the search code bundle
  basedir
    Path to the generated site's root directory
  config.yml
    Path to the site's config.yml containing a `jekyll_pages_api_search` entry
  pages.json
    Path to the output file generated by `jekyll_pages_api`
  baseURL
    URL prefix of every page of the generated site
  title_prefix
    Prefix to strip from page titles
  body_element_tag
    Tag (or tag prefix) identifying the main content element within the <body>
    element of each document. Can be a complete tag (ending in '>'), or the
    prefix of a longer tag. Used to strip boilerplate out of the content
    exported via the API.
END_USAGE

if ARGV.length == 1 && ARGV[0] == '-h'
  puts USAGE
  exit
end

unless [3, 5, 6].include? ARGV.length
  $stderr.puts "Wrong number of arguments: #{ARGV.length}"
  $stderr.puts USAGE
  exit 1
end

# Handle --assets case
if ARGV.length == 5
  if ARGV[0] == '--assets'
    baseURL, scss, html, js = ARGV[1..ARGV.size]
    [scss, html, js].each {|i| FileUtils.mkdir_p File.dirname(i)}
    FileUtils.cp JPAS::Sass::INTERFACE_FILE, scss
    File.open(html, 'w') {|f| f << JPAS::SearchInterfaceTag::CODE}
    File.open(js, 'w') {|f| f << JPAS::LoadSearchTag::generate_script(baseURL)}
    exit
  else
    $stderr.puts "Wrong number of arguments: #{ARGV.length}"
    $stderr.puts USAGE
   exit 1
 end
end

basedir, config, pages_json, baseURL, title_prefix, body_element_tag = ARGV

unless File.exist? basedir
  $stderr.puts "#{basedir} does not exist"
  exit 1
end

if ARGV.length == 3 && !File.exist?(pages_json)
  $stderr.puts "#{pages_json} does not exist"
  exit 1
end

site = JPAS::Site.new basedir, config

# Generate pages.json if it doesn't already exist.
if baseURL.nil?
  site.load_pages_json pages_json
else
  site.pages << ::JekyllPagesApi::Generator.new(
    ::JekyllPagesApi::GeneratedSite.new(
      baseURL, basedir, title_prefix, body_element_tag)).page
end

# Build the index; output pages_json if necessary; gzip outputs.
index = JPAS::SearchIndexBuilder.build_index site
index_outfile = File.join site.source, index.name
output = { index_outfile => index.output.to_s }
output[pages_json] = site.pages.first.output unless File.exist? pages_json
output.each do |outfile, content|
  File.open(outfile, 'w') {|f| f << content}
  JPAS::Compressor::gzip_in_memory_content outfile => content
end

# Copy the search bundle files.
target_path = File.join site.source, ASSETS_DIR
FileUtils.mkdir_p target_path
JPAS::JavascriptCopier::search_bundle_paths {|f| FileUtils.cp f, target_path}
